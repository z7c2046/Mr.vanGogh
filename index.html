<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mr.vanGogh-李志</title>
    <style>
        body {
            scroll-behavior: smooth;
            background-color: #cd353b;
            /* background-color: #e3e5e5; */
            display: grid;
            grid-template-areas:
                "head"
                "container"
                "banner"
            ;
            row-gap: 10px;
        }

        .head {
            grid-template-areas: head;
        }

        .container {
            grid-template-areas: container;
        }

        .banner {
            grid-template-areas: banner;
        }

        /* =========================================== */
        .head {
            display: grid;
            align-items: center;
            justify-items: center;
            margin-bottom: 20px;
        }

        .head h1 {
            color: white;
            margin: 30px auto;
        }

        .head .video {
            margin: 20px 0px;
        }

        .container,
        .banner {
            position: relative;
            /* overflow: hidden; */
        }

        .container .commentBox,
        .banner .commentBox1 {
            width: 300px;
            background-color: rgb(236, 236, 236);
            border-radius: 5px;
            margin: 0px 20px 20px 20px;
            /* 上右下左 */
            padding: 10px;
            /* word-wrap: break-word; */
            /* 自动换行 */
            float: left;
            border: 0.8px solid black;
            display: grid;
            grid-template-areas:
                "profile comment comment"
                "profile nickname nickname"
                "profile timestamp timestamp"
            ;
            column-gap: 10px;
        }





        /* =========================================== */
        .commentBox div:nth-child(1),
        .commentBox1 div:nth-child(1) {
            grid-area: profile;
        }

        .commentBox div:nth-child(1) img,
        .commentBox1 div:nth-child(1) img {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            margin-top: 10px;
            margin-left: 5px;
        }

        .commentBox div:nth-child(2),
        .commentBox1 div:nth-child(2) {
            grid-area: comment;
        }

        .commentBox div:nth-child(2) p,
        .commentBox div:nth-child(2) p {
            margin-top: 0;
        }

        .commentBox div:nth-child(3),
        .commentBox1 div:nth-child(3) {
            grid-area: nickname;
            text-align: right;
            font-size: 14px;
        }

        .commentBox div:nth-child(4),
        .commentBox1 div:nth-child(4) {
            grid-area: timestamp;
            text-align: right;
            font-size: 14px;
        }

        h2 {
            color: white;
            height: 40px;
            /* border: 0.8px solid black; */
            /* 测试时加的边框，为了看清楚高度对布局的影响 */
            margin: 20px 0px 20px 0px;
            /* 上右下左 */
        }


        @media only screen and (min-width: 100px) and (max-width: 741px) {
            body {
                font-weight: bold;
            }

            .video {
                width: 310px;
                height: 233px;
            }

        }

        @media only screen and (min-width: 740px) and (max-width: 899px) {
            body {
                font-weight: bold;
            }

            .video {
                width: 400px;
                height: 300px;
            }


        }

        @media screen and (min-width:900px) {

            .commentBox:hover,
            .commentBox1:hover {
                font-weight: bold;
                transform: scaleX(1.07) scaleY(1.07);
                transition: transform 0.5s;
            }
        }
    </style>
    <script src="convert.js"></script>
</head>

<body>
    <div class="head">
        <h1>梵高先生-李志</h1>

        <iframe class="video" width="900px" height="506px" src="https://www.youtube.com/embed/saQZYlLc-7E"
            title="YouTube video player" frameborder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
            allowfullscreen></iframe>
    </div>

    <div id="container" class="container">
        <h2 class="hotCommentsTittle">丨熱門評論</h2>
        <div class="commentBox">
        </div>
    </div>

    <div id="banner" class="banner">
        <h2 class="commentsTittle">丨更多評論</h2>
        <div class="commentBox1">
        </div>
    </div>

    <script>
        var container = document.getElementById("container"); //评论区的容器
        var banner = document.getElementById("banner"); //更多评论的容器
        var commentBox = document.getElementsByClassName("commentBox"); //如英语所示：每一个评论的盒子，拿来装头像，评论，昵称和日期这4个元素
        var commentBox1 = document.getElementsByClassName("commentBox1");

        function createElements(fatherElement, needsElement) { //函数传参。传父级元素进去，和要添加的元素
            var needsElement = document.createElement(needsElement); //创建div元素(这个创建的是评论的div，之后还需要用户名，头像，日期)
            fatherElement.appendChild(needsElement); //添加到节点
        }
        // 获取数据
        async function getData(id) {
            const response = await fetch(
                "https://netease-cloud-music-api-zeta-plum.vercel.app/comment/music?id=" + id);
            const data = await response.json();
            console.log(data);

            hotComments = data.hotComments
            comments = data.comments



            function godDamnFuckingCreate() { //操他媽的全都是循環創建，真几把麻烦TMD

                function addClassName(title, fatherElements, sonElementsName) {//给刚刚新创建的div加上commentBox类名
                    for (let i = 0; i < title.length; i++) {
                        createElements(fatherElements, "div");
                        fatherElements.getElementsByTagName("div")[i].classList.add(
                            sonElementsName);
                    }
                }
                addClassName(hotComments, container, "commentBox")/* 热门评论 */
                addClassName(comments, banner, "commentBox1")/* 近期评论 */

                function create4BasicElements(title, fatherElements) {//创建4个div元素
                    for (let j = 0; j < 4; j++) {
                        for (let i = 0; i < title.length; i++) {
                            createElements(fatherElements[i], "div");
                        }
                    }
                }
                create4BasicElements(hotComments, commentBox)
                create4BasicElements(comments, commentBox1)
                /* =============================================== */
                function createElementsBy2ComementBox(theBox) {//在上面创建的各个div元素中在各自创建图片，文本span标签，待会用来注入数据且方便css布局控制
                    for (let i = 0; i < theBox.length; i++) {
                        createElements(theBox[i].getElementsByTagName("div")[0], "img");
                        createElements(theBox[i].getElementsByTagName("div")[1], "p");
                        createElements(theBox[i].getElementsByTagName("div")[2], "span");
                        createElements(theBox[i].getElementsByTagName("div")[3], "span");
                    }
                    // 这里困扰了我很久，因为和下面那个循环结构一样，我试图再次新建一个传参的函数中放一个循环，来达到“1行命令，4行调用 + 传参”实现
                    // 但是！
                    // 使用了函数之后：就出现了么一个div之中都创建了4个“基本元素”
                    //❌错误写法：
                    // for (let j = 0; j < 4; j++) {
                    //         createElements(theBox[i].getElementsByTagName("div")[j], elements);
                    //     }
                    // }
                    // theSecond("img")
                    // theSecond("p")
                    // theSecond("span")*2
                    // 原理是，只需要在第1个div中创建图片标签
                    //              在第2个div中创建文本标签
                    //              。。。
                    //              1次循环可以解决“第1个”元素的问题
                    //              第2次循环的时候会把已经执行过的第1次调用+传参的函数再执行一次
                    //              这就是症结所在！！！！！
                    // 但是使用了使用了循环，我进行断点测试的时候，第一次是成功的
                    // 但是在进行第二次循环的时候，就出现问题了，就在div中创建了两遍基本元素，最终撑开了页面
                }
                createElementsBy2ComementBox(commentBox)
                createElementsBy2ComementBox(commentBox1)
                /* ================================================ */
                var tempComments
                function injectionDataBy2ComementBox(title, tag) {
                    for (let i = 0; i < title.length; i++) { //在上一步的div元素里创建img标签（头像）顺便注入数据
                        tag[i].getElementsByTagName("div")[0].getElementsByTagName("img")[0].src = title[i].user.avatarUrl

                        tempComments = title[i].content
                        // alert(traditionalized(tempComments))
                        tag[i].getElementsByTagName("div")[1].getElementsByTagName("p")[0].innerHTML = traditionalized(tempComments)
                        tag[i].getElementsByTagName("div")[2].getElementsByTagName("span")[0].innerHTML = "-" + title[i].user.nickname
                        tag[i].getElementsByTagName("div")[3].getElementsByTagName("span")[0].innerHTML = title[i].timeStr
                    }
                }
                injectionDataBy2ComementBox(hotComments, commentBox)
                injectionDataBy2ComementBox(comments, commentBox1)
            }
            godDamnFuckingCreate();
            waterfalls("container", "commentBox") //瀑布流函数
            waterfalls("banner", "commentBox1")
        }
        //瀑布流函数
        function waterfalls(father, son) {
            //一、父盒子定位
            //1.1 获取内外层容器标签
            var outContainer = document.getElementById(father);
            var innerContainer = outContainer.getElementsByClassName(son);

            var boxWidth = innerContainer[0].offsetWidth + 40; //1.2 盒子宽度------------后面+40是通过css给box设置的左右两边的margin
            var screenWidth = document.body.clientWidth; //1.3 当前屏幕宽度
            var columns = parseInt(screenWidth / boxWidth); //1.4 列数
            //1.5 父盒子居中，给父盒子设置宽度
            outContainer.style.width = columns * boxWidth + 'px';
            outContainer.style.margin = '0 auto 50px';

            //二、子盒子定位（从第二行开始）
            //2.1 定义变量
            //盒子高度、盒子高度数组、最矮盒子高度、最矮盒子高度的索引
            var boxHeight, boxHeightArray = [],
                minBoxHeight, minIndex;
            //2.2 遍历所有的盒子
            for (let i = 0; i < innerContainer.length; i++) {

                boxHeight = innerContainer[i].offsetHeight + 20; //盒子高度-----------后面+20是通过css给box设置的下边margin
                //2.3 判断是否是第一行
                if (i < columns) {
                    boxHeightArray.push(boxHeight); //2.4 盒子高度存进数组
                } else {
                    //2.5 剩余行做定位
                    minBoxHeight = boxHeightArray[findIndex(boxHeightArray)]; //2.6 取出数组中最矮盒子的高度
                    minIndex = findIndex(boxHeightArray); //2.7 取出最矮盒子再数组中的索引

                    /* 新加的！！！！作用是想要给父级元素撑开高度，以便后期布局，见代码255行*/
                    var maxBoxHeight = boxHeightArray[findMaxIndex(boxHeightArray)];
                    var maxIndex = findMaxIndex(boxHeightArray);

                    //2.8 剩余盒子的定位（第二行开始）
                    innerContainer[i].style.position = "absolute";
                    innerContainer[i].style.left = minIndex * boxWidth + 'px';
                    innerContainer[i].style.top = minBoxHeight + 80 +
                        'px'; //这里+80是我将标题“热门评论”移进来放在了第一行，所以要加上标题的高度及上下margin

                    boxHeightArray[minIndex] += boxHeight; //2.9 更新高度

                    /* 原理是瀑布流布局用的是absolute定位，而父级元素是relative定位，
                    无法撑开整个父级元素的高度，脱离了应有的文档流，
                    所以我直接为父级元素在循环结束设置高度=最高的盒子的高度
                     */
                    if (columns == 1) {
                        outContainer.style.height = maxBoxHeight + boxHeight + 80 - 20 + 'px';
                    } else {
                        outContainer.style.height = maxBoxHeight + 80 - 20 + 'px';
                    }

                }

            }
            /* 可以传递一个「数组」类型的参数
            作用是找到数组中的最小值
            并且特别注意返回的是最小值的「下标」 */
            function findIndex(arr) {
                var j = 0;
                for (i in arr) {
                    if (arr[j] > arr[i])
                        j = i;
                }
                return j;
            }
            /* 传递一个「数组」类型的参数，返回其最大值的「下标」 */
            function findMaxIndex(arr) {
                var j = 0;
                for (i in arr) {
                    if (arr[j] < arr[i])
                        j = i;
                }
                return j;
            }
            /* 测试 */
            // var list = [1, 2, 55, 66, 4, 78, 3, 5, 8, 96, 7, 5];
            // findMaxIndex(list);

            function getStyle(obj, attr) { //获取非行间样式，obj是对象，attr是值
                if (obj.currentStyle) { //针对ie获取非行间样式
                    return obj.currentStyle[attr];
                } else {
                    return getComputedStyle(obj, false)[attr]; //针对非ie
                };
            };
            // getStyle(document.querySelector("hotCommentsTittle"), "margin")
        }

        //页面加载时，就调用接口数据
        window.onload = function () {
            getData(26508240);
            //梵高先生的id
        }
        //当页面尺寸发生变化时，触发函数，实现响应式
        window.onresize = function () {
            waterfalls("container", "commentBox")
            waterfalls("banner", "commentBox1")
        }
    </script>
</body>

</html>
